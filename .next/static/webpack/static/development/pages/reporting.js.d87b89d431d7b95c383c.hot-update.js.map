{"version":3,"file":"static/webpack/static/development/pages/reporting.js.d87b89d431d7b95c383c.hot-update.js","sources":["webpack:///./components/special/ShowPins.js","webpack:///./node_modules/arrive/src/arrive.js"],"sourcesContent":["import withContainers from \"../wrappers/withContainer\";\n\nimport { Global as globalState } from \"./Global\";\nimport React, { Component } from \"react\";\nimport { Subscribe } from \"unstated\";\nimport { arrive } from \"arrive\";\n\nimport { getIframeScrollPosition } from \"../../lib/helpers\";\n\nimport styled from \"styled-components\";\n\nimport SickButton from \"../styles/SickButton\";\nimport Pin from \"./Pin\";\n\nconst ShowPinsDiv = styled.div`\n  position: absolute;\n  top: ${props => (props.scrollTop ? props.scrollTop : \"0px\")};\n  left: 0px;\n  right: 0px;\n  bottom: 0px;\n  z-index: 2;\n  pointer-events: none;\n`;\n\nvar timeout = \"\";\n\nclass ShowPins extends Component {\n  state = {\n    scrollTop: 0\n  };\n\n  componentDidMount() {\n    //get initial scroll pos\n\n    //TODO: THIS NEEDS TO WAIT FOR IFRAME TO EXIST\n    setTimeout(() => {\n      this._updateScrollPosition();\n      //attach scroll listener\n      document\n        .getElementById(\"iframe\")\n        .contentWindow.document.addEventListener(\n          \"scroll\",\n          this._handleScroll,\n          false\n        );\n    }, 2000);\n  }\n\n  //polling is almost accurate but needs a trail off perhaps an interval or a while statement\n  //that runs several more times over a few seconds.\n\n  _updateScrollPosition = event => {\n    console.log(\"update scroll position\");\n    var scroll = \"\";\n    var iframeScrollPosition = document\n      .getElementById(\"iframe\")\n      .contentWindow.document.getElementById(\"iframeScrollPosition\");\n\n    if (iframeScrollPosition.getAttribute(\"y\")) {\n      scroll = -iframeScrollPosition.getAttribute(\"y\");\n    } else {\n      scroll = 0;\n    }\n\n    this.setState({ scrollTop: scroll + \"px\" });\n  };\n\n  _handleScroll = me => {\n    console.log(\"Scroll listener.\");\n    window.clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      this._updateScrollPosition();\n      setTimeout(this._updateScrollPosition(), 150);\n    }, 200);\n    this._updateScrollPosition();\n  };\n\n  componentWillUnmount() {\n    // window.removeEventListener('scroll', this._updateScrollPosition, false);\n  }\n  render() {\n    var block = this.props.block;\n    return (\n      <div>\n        <Subscribe to={[globalState]}>\n          {test => (\n            <ShowPinsDiv scrollTop={this.state.scrollTop}>\n              {test.state.pins.map((pin, i) => {\n                return <Pin key={i} pin={pin} test={test} />;\n              })}\n            </ShowPinsDiv>\n          )}\n        </Subscribe>\n      </div>\n    );\n  }\n}\n\n// export default withContainers([globalState])(ShowPins);\nexport default ShowPins;\n","/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\nvar Arrive = (function(window, $, undefined) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var Arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, Arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, Arrive, \"unbindAllLeave\");\n\n  return Arrive;\n\n})(window, typeof jQuery === 'undefined' ? null : jQuery, undefined);"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAQA;AACA;AACA;;;;;;;;;;;;;;;;;;AACA;AACA;AADA;AACA;AAuBA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;;;;;;AA7CA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAOA;AACA;AAGA;AACA;;;AA2BA;AAEA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAJA;AAUA;;;;AArEA;AACA;AACA;AAuEA;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}